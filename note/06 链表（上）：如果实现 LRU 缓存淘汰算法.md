# 06 链表（上）：如果实现 LRU 缓存淘汰算法
> 缓存是一种提高读写性能的技术。
> 缓存有 CPU 缓存、浏览器缓存、数据库缓存...
> 缓存的清理策略有 先进先出、最少使用、最近最少使用策略...

可以使用链表实现 LRU（最近最少使用） 算法

## 什么是链表
>数组是一种线性表结构，采用一段连续的内存空间来存储一组相同类型的数据。
>链表并不需要连续的内存空间，它通过“指针”将一组**零散的内存块**串联起来使用。零散的内存块，我们称之为**结点**，每个结点除了存储内存地址之外，还需一个额外的空间来记录指针。这个指针记录链表中下一个结点的地址，称之为后继指针。

数组相对于链表来说，对内存有一定要求，更容易出现内存申请失败的情况。


## 链表的分类
### 单链表
单链表第一个结点称为头结点，头结点记录链表的基地址；单链表的最后一个结点成为尾结点，尾结点的后继指针指向一个空地址 `null`。

链表的插入和删除操作都比数组效率要高，但随机访问效率比数组要低。
### 循环链表
循环链表的尾结点的后继指针不再指向一个空地址，而是指向链表的头结点，形成一条环。循环链表的优点是从链尾到链头比较方便...
### 双向链表
双向链表想比较与单链表来说，除了有后继指针之外，还具有指向前一个结点地址的前驱指针。

双向链表相对于单链表来说需要更多的内存空间，但是灵活性更好，可以更高效的实现查找前驱结点，同时插入和删除也比单链表高效

以删除操作为例：
1.删除结点中“值等于给定值的结点”
2.删除给定指针指向的结点

对于第一种情况来说，两种链表没有什么不同，都需要遍历链表来查找相对应的结点，时间复杂度都是 O(n)。

但是对于第二种情况来说，删除结点的操作，需要知道删除结点的前驱结点和后继结点地址。这时候双链表的时间负责度为 O(1)，而单链表的时间复杂度仍为 O(n)。

**tips：时间换空间，空间换时间。**

## 链表与数组
链表与数组一些操作的时间复杂度比较：

|       | 数组   | 链表   |
|-------|------|------|
| 插入、删除 | O(n) | O(1) |
| 随机访问  | O(1) | O(n) |

数组：对 CPU 缓存比较友好，但是需要连续的内存空间，扩容时需要进行数据搬迁。
链表：对于插入和删除操作更友好。但是需要额外的空间来存储指针。同时对于链表的插入和操作操作，可能会频繁的申请和释放内存，容易产生内存碎片，会频繁触发GC。



